<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>p5.js Kaleidoscope</title>
    <style>
        /* Basic CSS to ensure the canvas fills the screen */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 14px;
            text-align: center;
        }
    </style>
    <!-- Import the p5.js library from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
</head>
<body>
<div class="info">Move your mouse to draw | Press any key to clear</div>
<script>
    // --- p5.js Sketch ---

    // Number of symmetrical slices in the kaleidoscope.
    // Try changing this value to 6, 8, 10, etc.
    const symmetry = 12;

    // The angle for each slice
    let angle;

    // Hue value for HSB color mode
    let hueValue = 0;

    // Setup function runs once when the program starts
    function setup() {
        // Create a canvas that fills the entire browser window
        createCanvas(windowWidth, windowHeight);

        // Set the angle mode to degrees for easier rotation
        angleMode(DEGREES);

        // Set the background color
        background(0);

        // Calculate the angle for each slice
        angle = 360 / symmetry;
    }

    // Draw function runs continuously in a loop
    function draw() {
        // Translate the origin to the center of the canvas
        // All drawing will be relative to this point
        translate(width / 2, height / 2);

        // Only draw if the mouse is being moved
        if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
            // Calculate mouse position relative to the new (0,0) center
            const mx = mouseX - width / 2;
            const my = mouseY - height / 2;

            // Calculate previous mouse position relative to the center
            const pmx = pmouseX - width / 2;
            const pmy = pmouseY - height / 2;

            // Calculate the speed of the mouse movement
            const speed = dist(mx, my, pmx, pmy);

            // Set the stroke weight based on speed for a dynamic effect
            const strokeWeightValue = map(speed, 0, 20, 4, 10);
            strokeWeight(strokeWeightValue);

            // Use HSB color mode to cycle through colors beautifully
            colorMode(HSB, 360, 100, 100);
            hueValue = (hueValue + 1) % 360; // Increment hue value
            stroke(hueValue, 80, 100);

            // This is the core of the kaleidoscope effect.
            // We loop through each slice, rotate the canvas, and draw the line.
            for (let i = 0; i < symmetry; i++) {
                // Rotate the canvas by the slice angle
                rotate(angle);

                // Draw a line from the previous to the current mouse position
                line(mx, my, pmx, pmy);

                // To create the reflection, we flip the canvas vertically
                // and draw the line again.
                push(); // Save the current state
                scale(1, -1); // Flip it!
                line(mx, my, pmx, pmy);
                pop(); // Restore the state
            }
        }
    }

    // This function is called whenever a key is pressed
    function keyPressed() {
        // Clear the canvas by drawing the background again
        background(0);
    }

    // This function is called when the browser window is resized
    function windowResized() {
        // Resize the canvas to the new window dimensions
        resizeCanvas(windowWidth, windowHeight);
        // Redraw the background
        background(0);
    }

</script>
</body>
</html>
